  <div id="readme" class="readme blob instapaper_body">
    <article class="markdown-body entry-content" itemprop="text"><h2><a id="user-content-existing-boundaries" class="anchor" aria-hidden="true" href="./5.08.ExistingFeatureAreas.md#existing-boundaries"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现有边界</font></font></h2>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现有的边界</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，是指非矩形地理区域的周长;</font><font style="vertical-align: inherit;">例如区域边界，人口普查区域或类似区域。</font><font style="vertical-align: inherit;">在FME中，这些由现有的多边形要素表示。</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任何多边形要素都可以读入工作空间，但其周长不能用于剪切通过</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">读模块</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">读入工作空间的要素</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是，它可用于通过</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转换器</font></font></em><font style="vertical-align: inherit;">剪切正在读入工作空间的要素。</font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，不使用读模块及其参数，而是使用现有边界来通过FeatureReader转换器或Clipper转换器来剪切数据。</font></font></p>
<hr>
<h3><a id="user-content-selecting-the-existing-area" class="anchor" aria-hidden="true" href="./5.08.ExistingFeatureAreas.md#selecting-the-existing-area"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择现有区域</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果现有区域要素是数据集中的单个要素，则可以将其读入工作空间并立即使用。</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，如果它是较大数据集的一部分，则需要从其余数据中过滤掉它。</font><font style="vertical-align: inherit;">如果读模块有一个where子句（并且可以通过这种方式识别该要素），那么它是过滤数据的最有效方式：</font></font></p>
<p><a target="_blank" rel="noopener noreferrer" href="./Images/Img5.023.ReaderWhereClause.png"><img src="./Images/Img5.023.ReaderWhereClause.png" alt="" style="max-width:100%;"></a></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处使用WHERE子句将地理数据库中的数据过滤为所需的要素。</font><font style="vertical-align: inherit;">连接上的要素计数仅显示传递的单个要素。</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果读模块没有WHERE子句参数，则可以读取完整数据集，并使用转换器（如Tester或TestFilter）过滤掉所需的要素：</font></font></p>
<p><a target="_blank" rel="noopener noreferrer" href="./Images/Img5.024.TesterNotWhereClause.png"><img src="./Images/Img5.024.TesterNotWhereClause.png" alt="" style="max-width:100%;"></a></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，这种技术效率不高，因为 - 在上面的例子中 - 需要读取所有六个要素而不是一个。</font></font></p>
<hr>
<h3><a id="user-content-featurereader" class="anchor" aria-hidden="true" href="./5.08.ExistingFeatureAreas.md#featurereader"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FeatureReader</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要使用FeatureReader按现有区域过滤数据，将多边形要素路由到FeatureReader Initiator端口。</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里将单个垃圾计划区域（Blue zone，north）传递给FeatureReader以用作过滤器。</font><font style="vertical-align: inherit;">我们的想法是只返回属于垃圾收集区的地址。</font><font style="vertical-align: inherit;">参数设置如下：</font></font></p>
<p><a target="_blank" rel="noopener noreferrer" href="./Images/Img5.025.FeatureReaderParameters.png"><img src="./Images/Img5.025.FeatureReaderParameters.png" alt="" style="max-width:100%;"></a></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请注意，FeatureReader设置为从地址地理数据库中读取。</font><font style="vertical-align: inherit;">空间过滤器参数告诉转换器仅读取传入多边形要素（垃圾收集区域）内的要素（地址）。</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些要素通过动态添加到FeatureReader的端口输出：</font></font></p>
<p><a target="_blank" rel="noopener noreferrer" href="./Images/Img5.026.FeatureReaderOutput.png"><img src="./Images/Img5.026.FeatureReaderOutput.png" alt="" style="max-width:100%;"></a></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处的要素计数表明垃圾收集区内有955个地址。</font><font style="vertical-align: inherit;">如果您注意到GarbageSchedule已经具有NumAddresses属性，是的，它是相同的值！</font></font></p>
<hr>
<h3><a id="user-content-clipper" class="anchor" aria-hidden="true" href="./5.08.ExistingFeatureAreas.md#clipper"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clipper</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clipper转换器是一种对已经读入工作空间的数据进行空间过滤的方法（其他类似的转换器是PointOnAreaOverlayer或SpatialFilter）。</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里将地址数据库读入工作空间，Clipper用于过滤掉属于所选垃圾收集区域的那些地址：</font></font></p>
<p><a target="_blank" rel="noopener noreferrer" href="./Images/Img5.027.ClipperClippingAddresses.png"><img src="./Images/Img5.027.ClipperClippingAddresses.png" alt="" style="max-width:100%;"></a></p>
<hr>

<table>
<tbody><tr>
<td>
<i></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vector女士说......
</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">

在上面的例子中，Clipper和FeatureReader的结果完全相同。</font><font style="vertical-align: inherit;">那么为什么FeatureReader成为首选？</font><font style="vertical-align: inherit;">选择适用的所有原因：
 </font></font><br><br><a href="http://52.73.3.37/fmedatastreaming/Manual/QAResponse2017.fmw?chapter=23&amp;question=1&amp;answer=1&amp;DestDataset_TEXTLINE=C%3A%5CFMEOutput%5CQAResponse.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.它可以更快，更节省资源</font></font></a>
<br><a href="http://52.73.3.37/fmedatastreaming/Manual/QAResponse2017.fmw?chapter=23&amp;question=1&amp;answer=2&amp;DestDataset_TEXTLINE=C%3A%5CFMEOutput%5CQAResponse.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.它允许多个区域用作现有区域</font></font></a>
<br><a href="http://52.73.3.37/fmedatastreaming/Manual/QAResponse2017.fmw?chapter=23&amp;question=1&amp;answer=3&amp;DestDataset_TEXTLINE=C%3A%5CFMEOutput%5CQAResponse.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.它适用于栅格数据</font></font></a>
<br><a href="http://52.73.3.37/fmedatastreaming/Manual/QAResponse2017.fmw?chapter=23&amp;question=1&amp;answer=4&amp;DestDataset_TEXTLINE=C%3A%5CFMEOutput%5CQAResponse.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.它有更多的空间过滤选择</font></font></a>

</td>
</tr>
</tbody></table>
</article>
  </div>
